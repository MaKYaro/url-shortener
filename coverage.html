
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>url-shortener: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/MaKYaro/url-shortener/cmd/url-shortener/main.go (0.0%)</option>
				
				<option value="file1">github.com/MaKYaro/url-shortener/internal/config/config.go (0.0%)</option>
				
				<option value="file2">github.com/MaKYaro/url-shortener/internal/domain/alias.go (100.0%)</option>
				
				<option value="file3">github.com/MaKYaro/url-shortener/internal/http-server/router/mocks/URLSaver.go (80.0%)</option>
				
				<option value="file4">github.com/MaKYaro/url-shortener/internal/http-server/router/router.go (0.0%)</option>
				
				<option value="file5">github.com/MaKYaro/url-shortener/internal/http-server/router/save.go (100.0%)</option>
				
				<option value="file6">github.com/MaKYaro/url-shortener/internal/http-server/server/server.go (0.0%)</option>
				
				<option value="file7">github.com/MaKYaro/url-shortener/internal/lib/http/response/response.go (100.0%)</option>
				
				<option value="file8">github.com/MaKYaro/url-shortener/internal/lib/logger/slogdiscard/slogdiscard.go (66.7%)</option>
				
				<option value="file9">github.com/MaKYaro/url-shortener/internal/lib/random/random.go (100.0%)</option>
				
				<option value="file10">github.com/MaKYaro/url-shortener/internal/services/url-shortener/mocks/AliasGenerator.go (84.6%)</option>
				
				<option value="file11">github.com/MaKYaro/url-shortener/internal/services/url-shortener/mocks/URLGetter.go (78.9%)</option>
				
				<option value="file12">github.com/MaKYaro/url-shortener/internal/services/url-shortener/mocks/URLRemover.go (0.0%)</option>
				
				<option value="file13">github.com/MaKYaro/url-shortener/internal/services/url-shortener/mocks/URLSaver.go (84.6%)</option>
				
				<option value="file14">github.com/MaKYaro/url-shortener/internal/services/url-shortener/urlshortener.go (100.0%)</option>
				
				<option value="file15">github.com/MaKYaro/url-shortener/internal/storage/postgres/postgres.go (77.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "net/http"
        "os"
        "os/signal"
        "syscall"

        "log/slog"

        "github.com/MaKYaro/url-shortener/internal/config"
        "github.com/MaKYaro/url-shortener/internal/http-server/router"
        "github.com/MaKYaro/url-shortener/internal/http-server/server"
        "github.com/MaKYaro/url-shortener/internal/lib/random"
        urlshortener "github.com/MaKYaro/url-shortener/internal/services/url-shortener"
        "github.com/MaKYaro/url-shortener/internal/storage/postgres"
)

const (
        envLocal = "local"
        envProd  = "prod"
)

func main() <span class="cov0" title="0">{
        cfg := config.MustLoad()

        log := setupLogger(cfg.Env)
        log.Info("logger is working", slog.String("env", cfg.Env))
        log.Debug("debug masseges are enabled")

        storage, err := postgres.New(cfg.DBConn)
        defer storage.Close()

        if err != nil </span><span class="cov0" title="0">{
                log.Error("can't init storage", slog.String("error", err.Error()))
        }</span>
        <span class="cov0" title="0">log.Info("storage is working", slog.Any("storage", cfg.DBConn))

        aliasGenerator := random.NewGenerator(cfg.Alias.Length)
        shortener := urlshortener.New(
                log,
                storage,
                storage,
                storage,
                aliasGenerator,
                cfg.Alias.LifeLength,
        )

        router := router.NewRouter(log, http.NewServeMux(), shortener)

        log.Info("starting server", slog.String("address", cfg.Server.Address))

        srv := server.NewServer(
                cfg.Server.Address,
                router.InitRoutes(),
                cfg.Server.Timeout,
                cfg.Server.IdleTimeout,
        )

        go func() </span><span class="cov0" title="0">{
                stop := make(chan os.Signal, 1)
                signal.Notify(stop, syscall.SIGTERM, syscall.SIGINT)

                sign := &lt;-stop

                log.Info(
                        "stopping application",
                        slog.String("signal", sign.String()),
                )

                if err := srv.Shutdown(context.Background()); err != nil </span><span class="cov0" title="0">{
                        log.Error(
                                "failed to shutdown server",
                                slog.String("error", err.Error()),
                        )
                }</span>
                <span class="cov0" title="0">close(stop)</span>
        }()

        <span class="cov0" title="0">if err := srv.Run(); err != nil </span><span class="cov0" title="0">{
                log.Error("failed to start server")
        }</span>

        <span class="cov0" title="0">log.Info("server stopped")
        log.Info("application stopped")</span>
}

func setupLogger(env string) *slog.Logger <span class="cov0" title="0">{
        var log *slog.Logger

        switch env </span>{
        case envLocal:<span class="cov0" title="0">
                log = slog.New(slog.NewTextHandler(
                        os.Stdout,
                        &amp;slog.HandlerOptions{Level: slog.LevelDebug},
                ),
                )</span>
        case envProd:<span class="cov0" title="0">
                log = slog.New(slog.NewJSONHandler(
                        os.Stdout,
                        &amp;slog.HandlerOptions{Level: slog.LevelInfo},
                ),
                )</span>
        }
        <span class="cov0" title="0">return log</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "encoding/json"
        "flag"
        "os"
        "time"
)

type Config struct {
        Env    string       `json:"Env"`
        Server HTTPServer   `json:"HTTPServer"`
        DBConn DBConnConfig `json:"DBConn" env-required:"true"`
        Alias  AliasConfig  `json:"Alias"`
}

type HTTPServer struct {
        Address     string        `json:"Address" env-default:"localhost:8080"`
        Timeout     time.Duration `json:"Timeout" env-default:"4s"`
        IdleTimeout time.Duration `json:"IdleTimeout" env-default:"60s"`
        User        string        `json:"User" env-required:"true"`
        Password    string        `json:"Password" env-required:"true"`
}

type AliasConfig struct {
        Length     int           `json:"Length" env-default:"8"`
        LifeLength time.Duration `json:"LifeLength" env-default:"2592000000000000"`
}

type DBConnConfig struct {
        User     string `json:"User"`
        Password string `json:"Password"`
        Host     string `json:"Host"`
        Port     int    `json:"Port"`
        DBName   string `json:"DBName"`
}

// MustLoad parse config file in Config struct
// if there is no config file it panics
func MustLoad() *Config <span class="cov0" title="0">{
        path := fetchConfPath()
        if path == "" </span><span class="cov0" title="0">{
                panic("config path isn't set")</span>
        }

        <span class="cov0" title="0">if _, err := os.Stat(path); err != nil </span><span class="cov0" title="0">{
                panic("incorrect config file path: " + path)</span>
        }

        <span class="cov0" title="0">configData, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                panic("can't read config file: " + err.Error())</span>
        }

        <span class="cov0" title="0">var cfg Config

        if err = json.Unmarshal(configData, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                panic("can't parse config file: " + err.Error())</span>
        }
        <span class="cov0" title="0">return &amp;cfg</span>
}

// fetchConfPath finds config path in
// flag &lt; env
func fetchConfPath() string <span class="cov0" title="0">{
        path := os.Getenv("CONFIG_PATH")
        if path != "" </span><span class="cov0" title="0">{
                return path
        }</span>

        <span class="cov0" title="0">flag.StringVar(&amp;path, "config-path", "./path/to/conf.json", "path to config file")
        flag.Parse()
        return path</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package domain

import "time"

type Alias struct {
        Value  string
        URL    string
        Expire time.Time
}

func (a *Alias) Expired() bool <span class="cov10" title="7">{
        return a.Expire.Before(time.Now())
}</span>

func (a *Alias) ExpireString() string <span class="cov1" title="1">{
        return a.Expire.String()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        domain "github.com/MaKYaro/url-shortener/internal/domain"
        mock "github.com/stretchr/testify/mock"
)

// URLSaver is an autogenerated mock type for the URLSaver type
type URLSaver struct {
        mock.Mock
}

// SaveURL provides a mock function with given fields: url
func (_m *URLSaver) SaveURL(url string) (*domain.Alias, error) <span class="cov5" title="2">{
        ret := _m.Called(url)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for SaveURL")</span>
        }

        <span class="cov5" title="2">var r0 *domain.Alias
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (*domain.Alias, error)); ok </span><span class="cov0" title="0">{
                return rf(url)
        }</span>
        <span class="cov5" title="2">if rf, ok := ret.Get(0).(func(string) *domain.Alias); ok </span><span class="cov0" title="0">{
                r0 = rf(url)
        }</span> else<span class="cov5" title="2"> {
                if ret.Get(0) != nil </span><span class="cov5" title="2">{
                        r0 = ret.Get(0).(*domain.Alias)
                }</span>
        }

        <span class="cov5" title="2">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(url)
        }</span> else<span class="cov5" title="2"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov5" title="2">return r0, r1</span>
}

// NewURLSaver creates a new instance of URLSaver. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewURLSaver(t interface {
        mock.TestingT
        Cleanup(func())
}) *URLSaver <span class="cov10" title="4">{
        mock := &amp;URLSaver{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="4">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="4">return mock</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package router

import (
        "log/slog"
        "net/http"

        "github.com/MaKYaro/url-shortener/internal/domain"
)

//go:generate go run github.com/vektra/mockery/v2@v2.43.2 --name=URLSaver
type URLSaver interface {
        SaveURL(url string) (*domain.Alias, error)
}

type Router struct {
        log    *slog.Logger
        router *http.ServeMux
        saver  URLSaver
}

func NewRouter(
        log *slog.Logger,
        router *http.ServeMux,
        saver URLSaver,
) *Router <span class="cov0" title="0">{
        return &amp;Router{
                log:    log,
                router: router,
                saver:  saver,
        }
}</span>

func (h *Router) InitRoutes() *http.ServeMux <span class="cov0" title="0">{
        h.router.HandleFunc("POST /url", SaveURL(h.log, h.saver))
        return h.router
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package router

import (
        "encoding/json"
        "log/slog"
        "net/http"

        resp "github.com/MaKYaro/url-shortener/internal/lib/http/response"
        "github.com/go-playground/validator"
)

type Request struct {
        URL string `json:"url" validate:"required,url"`
}

type Response struct {
        resp.Response
        Alias  string `json:"alias,omitempty"`
        Expire string `json:"expire,omitempty"`
}

func SaveURL(log *slog.Logger, urlSaver URLSaver) http.HandlerFunc <span class="cov10" title="4">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov10" title="4">{
                const op = "handlers.url.save.New"

                log = log.With(slog.String("op", op))

                var req Request
                err := json.NewDecoder(r.Body).Decode(&amp;req)
                if err != nil </span><span class="cov1" title="1">{
                        log.Error(
                                "failed to decode request body",
                                slog.String("error", err.Error()),
                        )

                        respBytes, _ := json.Marshal(resp.Error("falied to decode request"))
                        w.Write(respBytes)

                        return
                }</span>

                <span class="cov8" title="3">log.Info("request body decoded", slog.Any("request", req))

                if err := validator.New().Struct(req); err != nil </span><span class="cov1" title="1">{
                        log.Error(
                                "invalid request",
                                slog.String("error", err.Error()),
                        )
                        respBytes, _ := json.Marshal(resp.Error("invalid request"))
                        w.Write(respBytes)

                        return
                }</span>

                <span class="cov5" title="2">alias, err := urlSaver.SaveURL(req.URL)
                if err != nil </span><span class="cov1" title="1">{
                        log.Error(
                                "failed to save url",
                                slog.String("error", err.Error()),
                        )
                        respBytes, _ := json.Marshal(resp.Error("can't save url"))
                        w.Write(respBytes)

                        return
                }</span>

                <span class="cov1" title="1">log.Info(
                        "url added",
                        slog.Any("alias value", alias),
                )
                respBytes, _ := json.Marshal(Response{
                        Response: resp.OK(),
                        Alias:    alias.Value,
                        Expire:   alias.ExpireString(),
                })
                w.Write(respBytes)</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package server

import (
        "context"
        "net/http"
        "time"
)

type Server struct {
        httpServer *http.Server
}

func NewServer(
        address string,
        handler *http.ServeMux,
        timeout time.Duration,
        idleTimeout time.Duration,
) *Server <span class="cov0" title="0">{
        httpServer := &amp;http.Server{
                Addr:         address,
                Handler:      handler,
                ReadTimeout:  timeout,
                WriteTimeout: timeout,
                IdleTimeout:  timeout,
        }

        return &amp;Server{httpServer: httpServer}
}</span>

func (s *Server) Run() error <span class="cov0" title="0">{
        return s.httpServer.ListenAndServe()
}</span>

func (s *Server) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        return s.httpServer.Shutdown(ctx)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package response

type Response struct {
        Status string `json:"status"`
        Error  string `json:"error,omitempty"`
}

const (
        StatusOK    = "OK"
        StatusError = "Error"
)

func OK() Response <span class="cov1" title="1">{
        return Response{
                Status: StatusOK,
        }
}</span>

func Error(msg string) Response <span class="cov10" title="3">{
        return Response{
                Status: StatusError,
                Error:  msg,
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package slogdiscard

import (
        "context"
        "log/slog"
)

func NewDiscardLogger() *slog.Logger <span class="cov8" title="11">{
        return slog.New(NewDiscardHandler())
}</span>

type DiscardHandler struct{}

func NewDiscardHandler() *DiscardHandler <span class="cov8" title="11">{
        return &amp;DiscardHandler{}
}</span>

func (d *DiscardHandler) Enabled(_ context.Context, _ slog.Level) bool <span class="cov10" title="17">{
        return false
}</span>

func (d *DiscardHandler) Handle(_ context.Context, _ slog.Record) error <span class="cov0" title="0">{
        return nil
}</span>

func (d *DiscardHandler) WithAttrs(_ []slog.Attr) slog.Handler <span class="cov8" title="11">{
        return d
}</span>

func (d *DiscardHandler) WithGroup(_ string) slog.Handler <span class="cov0" title="0">{
        return d
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package random

import (
        "math/rand"
        "strings"
        "time"
)

const chars = "1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM"

type AliasGenerator struct {
        aliasLen int
}

func NewGenerator(aliasLen int) *AliasGenerator <span class="cov3" title="5">{
        return &amp;AliasGenerator{aliasLen: aliasLen}
}</span>

func (g *AliasGenerator) Generate() string <span class="cov5" title="10">{
        rnd := rand.New(rand.NewSource(time.Now().UnixNano()))

        sb := strings.Builder{}
        sb.Grow(g.aliasLen)
        for i := 0; i &lt; g.aliasLen; i++ </span><span class="cov10" title="132">{
                sb.WriteByte(chars[rnd.Intn(len(chars))])
        }</span>
        <span class="cov5" title="10">return sb.String()</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import mock "github.com/stretchr/testify/mock"

// AliasGenerator is an autogenerated mock type for the AliasGenerator type
type AliasGenerator struct {
        mock.Mock
}

// Generate provides a mock function with given fields:
func (_m *AliasGenerator) Generate() string <span class="cov10" title="10">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Generate")</span>
        }

        <span class="cov10" title="10">var r0 string
        if rf, ok := ret.Get(0).(func() string); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov10" title="10"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov10" title="10">return r0</span>
}

// NewAliasGenerator creates a new instance of AliasGenerator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAliasGenerator(t interface {
        mock.TestingT
        Cleanup(func())
}) *AliasGenerator <span class="cov6" title="4">{
        mock := &amp;AliasGenerator{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov6" title="4">{ mock.AssertExpectations(t) }</span>)

        <span class="cov6" title="4">return mock</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import mock "github.com/stretchr/testify/mock"

// URLGetter is an autogenerated mock type for the URLGetter type
type URLGetter struct {
        mock.Mock
}

// GetURL provides a mock function with given fields: alias
func (_m *URLGetter) GetURL(alias string) (string, error) <span class="cov10" title="3">{
        ret := _m.Called(alias)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetURL")</span>
        }

        <span class="cov10" title="3">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(alias)
        }</span>
        <span class="cov10" title="3">if rf, ok := ret.Get(0).(func(string) string); ok </span><span class="cov0" title="0">{
                r0 = rf(alias)
        }</span> else<span class="cov10" title="3"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov10" title="3">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(alias)
        }</span> else<span class="cov10" title="3"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov10" title="3">return r0, r1</span>
}

// NewURLGetter creates a new instance of URLGetter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewURLGetter(t interface {
        mock.TestingT
        Cleanup(func())
}) *URLGetter <span class="cov10" title="3">{
        mock := &amp;URLGetter{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov10" title="3">{ mock.AssertExpectations(t) }</span>)

        <span class="cov10" title="3">return mock</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import mock "github.com/stretchr/testify/mock"

// URLRemover is an autogenerated mock type for the URLRemover type
type URLRemover struct {
        mock.Mock
}

// DeleteURL provides a mock function with given fields: alias
func (_m *URLRemover) DeleteURL(alias string) error <span class="cov0" title="0">{
        ret := _m.Called(alias)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for DeleteURL")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(alias)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// NewURLRemover creates a new instance of URLRemover. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewURLRemover(t interface {
        mock.TestingT
        Cleanup(func())
}) *URLRemover <span class="cov0" title="0">{
        mock := &amp;URLRemover{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
        domain "github.com/MaKYaro/url-shortener/internal/domain"
        mock "github.com/stretchr/testify/mock"
)

// URLSaver is an autogenerated mock type for the URLSaver type
type URLSaver struct {
        mock.Mock
}

// SaveURL provides a mock function with given fields: alias
func (_m *URLSaver) SaveURL(alias *domain.Alias) error <span class="cov10" title="10">{
        ret := _m.Called(alias)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for SaveURL")</span>
        }

        <span class="cov10" title="10">var r0 error
        if rf, ok := ret.Get(0).(func(*domain.Alias) error); ok </span><span class="cov0" title="0">{
                r0 = rf(alias)
        }</span> else<span class="cov10" title="10"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov10" title="10">return r0</span>
}

// NewURLSaver creates a new instance of URLSaver. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewURLSaver(t interface {
        mock.TestingT
        Cleanup(func())
}) *URLSaver <span class="cov6" title="4">{
        mock := &amp;URLSaver{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov6" title="4">{ mock.AssertExpectations(t) }</span>)

        <span class="cov6" title="4">return mock</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package urlshortener

import (
        "errors"
        "fmt"
        "log/slog"
        "time"

        "github.com/MaKYaro/url-shortener/internal/domain"
        "github.com/MaKYaro/url-shortener/internal/storage"
)

var (
        ErrEnableToSave = errors.New("can't save url")
        ErrURLNotFound  = errors.New("url not found")
        ErrCantFindUrl  = errors.New("can't find url")
)

//go:generate go run github.com/vektra/mockery/v2@v2.43.2 --name=URLSaver
type URLSaver interface {
        SaveURL(alias *domain.Alias) error
}

//go:generate go run github.com/vektra/mockery/v2@v2.43.2 --name=URLGetter
type URLGetter interface {
        GetURL(alias string) (string, error)
}

//go:generate go run github.com/vektra/mockery/v2@v2.43.2 --name=URLRemover
type URLRemover interface {
        DeleteURL(alias string) error
}

//go:generate go run github.com/vektra/mockery/v2@v2.43.2 --name=AliasGenerator
type AliasGenerator interface {
        Generate() string
}

type URLSortener struct {
        log     *slog.Logger
        saver   URLSaver
        getter  URLGetter
        remover URLRemover
        gen     AliasGenerator
        dur     time.Duration
}

func New(
        log *slog.Logger,
        saver URLSaver,
        getter URLGetter,
        remover URLRemover,
        gen AliasGenerator,
        dur time.Duration,
) *URLSortener <span class="cov10" title="7">{
        return &amp;URLSortener{
                log:     log,
                saver:   saver,
                getter:  getter,
                remover: remover,
                gen:     gen,
                dur:     dur,
        }
}</span>

func (u *URLSortener) SaveURL(url string) (*domain.Alias, error) <span class="cov7" title="4">{
        const op = "services.urlshortener.SaveURL"

        log := u.log.With(slog.String("op", op))

        expire := time.Now().Add(u.dur)
        aliasValue := u.gen.Generate()
        aliasToSave := domain.Alias{Value: aliasValue, URL: url, Expire: expire}
        err := u.saver.SaveURL(&amp;aliasToSave)

        for err == storage.ErrAliasExists </span><span class="cov9" title="6">{
                log.Info(
                        "alias already exists, try to generate unique",
                        slog.String("alias", aliasValue),
                )
                aliasValue = u.gen.Generate()
                aliasToSave = domain.Alias{Value: aliasValue, URL: url, Expire: expire}
                err = u.saver.SaveURL(&amp;aliasToSave)
        }</span>

        <span class="cov7" title="4">if err != nil </span><span class="cov4" title="2">{
                log.Error(
                        "can't save alias",
                        slog.String("err", err.Error()),
                )
                return nil, fmt.Errorf("%s: %w", op, ErrEnableToSave)
        }</span>

        <span class="cov4" title="2">return &amp;aliasToSave, nil</span>
}

func (u *URLSortener) GetURL(alias string) (string, error) <span class="cov6" title="3">{
        const op = "services.urlshortener.GetURL"

        log := u.log.With(slog.String("op", op))

        url, err := u.getter.GetURL(alias)
        if err == storage.ErrURLNotFound </span><span class="cov1" title="1">{
                log.Error(
                        "url not found",
                        slog.String("error", err.Error()),
                )
                return "", fmt.Errorf("%s: %w", op, ErrURLNotFound)
        }</span>

        <span class="cov4" title="2">if err != nil </span><span class="cov1" title="1">{
                log.Error(
                        "can't find url",
                        slog.String("error", err.Error()),
                )
                return "", fmt.Errorf("%s: %w", op, ErrCantFindUrl)
        }</span>

        <span class="cov1" title="1">return url, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package postgres

import (
        "database/sql"
        "fmt"

        "github.com/MaKYaro/url-shortener/internal/config"
        "github.com/MaKYaro/url-shortener/internal/domain"
        "github.com/MaKYaro/url-shortener/internal/storage"
        "github.com/lib/pq"
)

type Storage struct {
        db *sql.DB
}

func New(cfg config.DBConnConfig) (*Storage, error) <span class="cov0" title="0">{
        const op = "storage.postgres.New"

        connStr := fmt.Sprintf(
                "host=%s port=%d user=%s password=%s dbname=%s sslmode=disable",
                cfg.Host,
                cfg.Port,
                cfg.User,
                cfg.Password,
                cfg.DBName,
        )
        db, err := sql.Open("postgres", connStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s: %w", op, err)
        }</span>
        <span class="cov0" title="0">return &amp;Storage{db: db}, nil</span>
}

func (s *Storage) SaveURL(alias *domain.Alias) error <span class="cov10" title="3">{
        const op = "storage.postgres.SaveURL"

        query := "INSERT INTO urls (alias, url, expire) VALUES ($1, $2, $3)"
        _, err := s.db.Exec(query, alias.Value, alias.URL, alias.Expire)

        if pqErr, ok := err.(*pq.Error); ok &amp;&amp; pqErr.Code.Name() == "unique_violation" </span><span class="cov1" title="1">{
                return fmt.Errorf("%s: %w", op, storage.ErrAliasExists)
        }</span>
        <span class="cov6" title="2">if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (s *Storage) GetURL(alias string) (string, error) <span class="cov10" title="3">{
        const op = "storage.postgres.GetURL"

        query := "SELECT url FROM urls WHERE alias = $1"
        row := s.db.QueryRow(query, alias)

        var url string
        err := row.Scan(&amp;url)

        if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                return "", fmt.Errorf("%s: %w", op, storage.ErrURLNotFound)
        }</span>
        <span class="cov6" title="2">if err != nil </span><span class="cov1" title="1">{
                return "", fmt.Errorf("%s: %w", op, err)
        }</span>

        <span class="cov1" title="1">return url, nil</span>
}

func (s *Storage) DeleteURL(alias string) error <span class="cov6" title="2">{
        const op = "storage.postgres.DeleteURL"

        query := "DELETE FROM urls WHERE alias = $1"
        _, err := s.db.Exec(query, alias)

        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("%s: can't delete url: %w", op, err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (s *Storage) Close() <span class="cov0" title="0">{
        s.db.Close()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
